{"entries":[{"timestamp":1731030915708,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":70,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"//% color=#126180 icon=\"\\uf0fb\" block=\"Tello Drone Control\"\n//% groups=\"['ESP8266', 'Tello']\"\nnamespace TelloControl {\n    // Initialize the connection variables\n    let telloIP = \"192.168.10.1\";\n    let commandPort = 8889;\n\n    // Command function to send UDP packets to Tello\n    function sendCommand(command: string): void {\n        serial.writeLine(`Sending command: ${command}`);\n        // Send command to ESP8266 via serial, modify this part based on your ESP8266 connection setup\n        serial.writeString(\"AT+CIPSEND=\" + command.length + \"\\r\\n\");\n        basic.pause(100);\n        serial.writeString(command + \"\\r\\n\");\n    }\n\n    // Function to initialize Tello control mode\n    //% block=\"initialize Tello into SDK mode\"\n    //% group=\"Tello\"\n    export function initialize(): void {\n        sendCommand(\"command\"); // Puts Tello into SDK mode\n        basic.pause(500);\n    }\n\n\n\n    //% block=\"land\"\n    //% group=\"Tello\"\n    export function land(): void {\n        sendCommand(\"land\");\n    }\n\n    //% block=\"takeoff\"\n    //% group=\"Tello\"\n    export function takeOff(): void {\n        sendCommand(\"takeoff\");\n    }\n\n}\n\nnamespace ESP8266_IoT {\n    enum Cmd {\n        None,\n        ConnectWifi,\n        ConnectThingSpeak,\n    }\n\n\n    export enum SchemeList {\n        //% block=\"TCP\"\n        TCP = 1,\n        //% block=\"TLS\"\n        TLS = 2\n    }\n\n    export enum QosList {\n        //% block=\"0\"\n        Qos0 = 0,\n        //% block=\"1\"\n        Qos1,\n        //% block=\"2\"\n        Qos2\n    }\n\n    let wifi_connected: boolean = false\n    let thingspeak_connected: boolean = false\n    let userToken_def: string = \"\"\n    let topic_def: string = \"\"\n    let thingSpeakDatatemp = \"\"\n\n    let serialCnt = 0\n    let recvString = \"\"\n    let scanWIFIAPFlag = 0\n    let currentCmd: Cmd = Cmd.None\n\n    const THINGSPEAK_HOST = \"api.thingspeak.com\"\n    const THINGSPEAK_PORT = \"80\"\n    // export function change(a:any,b:any){\n    //     SMARTIOT_HOST = a\n    //     SMARTIOT_PORT = b\n    // }\n\n    const EspEventSource = 3000\n    const EspEventValue = {\n        None: Cmd.None,\n        ConnectWifi: Cmd.ConnectWifi,\n        ConnectThingSpeak: Cmd.ConnectThingSpeak,\n    }\n\n\n    let TStoSendStr = \"\"\n\n    // write AT command with CR+LF ending\n    function sendAT(command: string, wait: number = 0) {\n        serial.writeString(`${command}\\u000D\\u000A`)\n        basic.pause(wait)\n    }\n\n    function restEsp8266() {\n        sendAT(\"AT+RESTORE\", 1000) // restore to factory settings\n        sendAT(\"AT+RST\", 1000) // rest\n        serial.readString()\n        sendAT(\"AT+CWMODE=1\", 500) // set to STA mode\n        sendAT(\"AT+SYSTIMESTAMP=1634953609130\", 100) // Set local timestamp.\n        sendAT(`AT+CIPSNTPCFG=1,8,\"ntp1.aliyun.com\",\"0.pool.ntp.org\",\"time.google.com\"`, 100)\n        basic.pause(3000)\n    }\n\n    function scanWIFIAP(ssid: string) {\n\n        let scanflag = 0\n        let mscnt = 0\n        recvString = \" \"\n        sendAT(`AT+CWLAPOPT=1,2,-100,255`)\n        sendAT(`AT+CWLAP`)\n        while (!(scanflag)) {\n\n            recvString = recvString + serial.readString()\n            basic.pause(1)\n            mscnt += 1\n            if (mscnt >= 3000) {\n                scanWIFIAPFlag = 0\n                break\n            }\n\n            if (recvString.includes(\"+CWLAP:(\")) {\n\n                mscnt = 0\n                recvString = recvString.slice(recvString.indexOf(\"+CWLAP:(\"))\n                scanflag = 1\n                while (1) {\n\n                    recvString += serial.readString()\n                    basic.pause(1)\n                    mscnt += 1\n\n                    // OLED.clear()\n                    // OLED.writeStringNewLine(_recvString)\n                    if (recvString.includes(\"OK\") || mscnt >= 3000) {\n\n                        if (mscnt >= 3000) {\n                            scanWIFIAPFlag = 0\n                        } else if (recvString.includes(ssid)) {\n                            scanWIFIAPFlag = 1\n                        } else {\n                            scanWIFIAPFlag = 0\n                        }\n                        break\n                    }\n                }\n            }\n\n        }\n        recvString = \" \"\n    }\n\n    /**\n     * Initialize ESP8266 module\n     */\n    //% block=\"set ESP8266|RX %tx|TX %rx|Baud rate %baudrate\"\n    //% tx.defl=SerialPin.P8\n    //% rx.defl=SerialPin.P12\n    //% ssid.defl=your_ssid\n    //% pw.defl=your_password weight=100\n    export function initWIFI(tx: SerialPin, rx: SerialPin, baudrate: BaudRate) {\n        serial.redirect(tx, rx, BaudRate.BaudRate115200)\n        basic.pause(100)\n        serial.setTxBufferSize(128)\n        serial.setRxBufferSize(128)\n        restEsp8266()\n    }\n\n    /**\n     * connect to Wifi router\n     */\n    //% block=\"connect Wifi SSID = %ssid|KEY = %pw\"\n    //% ssid.defl=your_ssid\n    //% pw.defl=your_pwd weight=95\n    export function connectWifi(ssid: string, pw: string) {\n\n        while (1) {\n            scanWIFIAP(ssid)\n            if (scanWIFIAPFlag) {\n                currentCmd = Cmd.ConnectWifi\n                sendAT(`AT+CWJAP=\"${ssid}\",\"${pw}\"`) // connect to Wifi router\n                control.waitForEvent(EspEventSource, EspEventValue.ConnectWifi)\n                while (!wifi_connected) {\n                    restEsp8266()\n                    sendAT(`AT+CWJAP=\"${ssid}\",\"${pw}\"`)\n                    control.waitForEvent(EspEventSource, EspEventValue.ConnectWifi)\n                }\n                break\n            } else {\n                restEsp8266()\n                currentCmd = Cmd.ConnectWifi\n                sendAT(`AT+CWJAP=\"${ssid}\",\"${pw}\"`)\n                control.waitForEvent(EspEventSource, EspEventValue.ConnectWifi)\n                if (wifi_connected) {\n                    break\n                }\n            }\n        }\n    }\n\n    /**\n     * Warning: Deprecated.\n     * Check if ESP8266 successfully connected to Wifi\n     */\n    //% block=\"Wifi connected %State\" weight=70\n    export function wifiState(state: boolean) {\n        return wifi_connected === state\n    }\n\n    /**\n     * Connect to ThingSpeak\n     */\n    //% block=\"connect thingspeak\"\n    //% write_api_key.defl=your_write_api_key\n    //% subcategory=\"ThingSpeak\" weight=90\n    export function connectThingSpeak() {\n        thingspeak_connected = true\n        // connect to server\n        // recvString = \" \"\n        // serialCnt = 0\n        // sendAT(`AT+CIPSTART=\"TCP\",\"${THINGSPEAK_HOST}\",${THINGSPEAK_PORT}`)\n        // currentCmd = Cmd.ConnectThingSpeak\n        // basic.pause(1)\n        // recvString += serial.readString()\n        // if (recvString == \" \") {\n        //     thingspeak_connected = false\n        //     //basic.showIcon(IconNames.Sad)\n        // } else {\n        //     control.waitForEvent(EspEventSource, EspEventValue.ConnectThingSpeak)\n\n        // } \n    }\n\n    /**\n     * Connect to ThingSpeak and set data.\n     */\n    //% block=\"set data to send ThingSpeak | Write API key = %write_api_key|Field 1 = %n1||Field 2 = %n2|Field 3 = %n3|Field 4 = %n4|Field 5 = %n5|Field 6 = %n6|Field 7 = %n7|Field 8 = %n8\"\n    //% write_api_key.defl=your_write_api_key\n    //% expandableArgumentMode=\"enabled\"\n    //% subcategory=\"ThingSpeak\" weight=85\n    export function setData(write_api_key: string, n1: number = 0, n2: number = 0, n3: number = 0, n4: number = 0, n5: number = 0, n6: number = 0, n7: number = 0, n8: number = 0) {\n        TStoSendStr = \"AT+HTTPCLIENT=2,0,\\\"http://api.thingspeak.com/update?api_key=\"\n            + write_api_key\n            + \"&field1=\"\n            + n1\n            + \"&field2=\"\n            + n2\n            + \"&field3=\"\n            + n3\n            + \"&field4=\"\n            + n4\n            + \"&field5=\"\n            + n5\n            + \"&field6=\"\n            + n6\n            + \"&field7=\"\n            + n7\n            + \"&field8=\"\n            + n8\n            + \"\\\",,,1\"\n    }\n\n    /**\n     * upload data. It would not upload anything if it failed to connect to Wifi or ThingSpeak.\n     */\n    //% block=\"Upload data to ThingSpeak\"\n    //% subcategory=\"ThingSpeak\" weight=80\n    export function uploadData() {\n        let mscnt = 0\n        //sendAT(`AT+CIPSEND=${TStoSendStr.length + 2}`, 300)\n        sendAT(TStoSendStr, 100) // upload data\n\n        while (1) {\n\n            recvString += serial.readString()\n            basic.pause(1)\n            mscnt += 1\n\n            // OLED.clear()\n            // OLED.writeStringNewLine(_recvString)\n            if (recvString.includes(\"OK\") || mscnt >= 3000 || recvString.includes(\"ERROR\")) {\n\n                break\n            }\n        }\n\n        recvString = \" \"\n        basic.pause(200)\n    }\n\n    /*\n     * Check if ESP8266 successfully connected to ThingSpeak\n     */\n    //% block=\"ThingSpeak connected %State\"\n    //% subcategory=\"ThingSpeak\" weight=65\n    export function thingSpeakState(state: boolean) {\n        return thingspeak_connected === state\n    }\n\n\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":8870,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":240,"start2":240,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1731030915707,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"TestOnExtension2\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1731031028257}